### লংগেস্ট ইনক্রিজিং সাবসিকোয়েন্স

ধরা যাক আমাদের নিচের ছবির মতো একটা অ‍্যারে আছে যার নাম A 

![image](https://user-images.githubusercontent.com/63524824/126882050-410c4793-e2db-4b21-9f11-4a9d3c1abf78.png)

একটা অ‍্যারের সাবসিকোয়েন্স বলতে বুঝায় অ‍্যারে থেকে কিছু এলিমেন্ট মুছে দিলে বাকি যে সিকোয়েন্সটা থাকে সেটা। এলিমেন্টগুলোর অর্ডারিং পরিবর্তন করা যাবে না। n  সাইজের একটা অ‍্যারের  2^n টি সাবসিকোয়েন্স থাকতে পারে (প্রতিটা এলিমেন্টের জন‍্য 
2টি চয়েস, রেখে দেয়া বা মুছে দেয়া)। ইনক্রিসিং সাবসিকোয়েন্স হলো এমন একটা সাবসিকোয়েন্স যার প্রতিটি পজিশনের ভ‍্যালু আগের পজিশনের ভ‍্যালুর থেকে বড়।


উপরের উদাহরণে [0,9]  , [5,9]  , [0,2,7]  , [0,2,3,4] কিছু ইনক্রিসিং সাবসিকোয়েন্স। সবথেকে লম্বা ইনক্রিসিং সাবসিকোয়েন্স বা LIS হলো [0,2,3,4]। 

প্রথমে আমরা চেষ্টা করবো LIS এর দৈর্ঘ‍্য বের করতে, এরপরে মূল সাবসিকোয়েন্সটাও ট্র‍্যাক করা শিখবো।


#### ইটারেটিভ এপ্রোচ  : 

আমাদের LIS বের করতে হবে n  সাইজের একটা অ‍্যারের মধ্যে থেকে।  এক্ষেত্রে  যদি কোনো Increasing Order এ সিকোয়েন্স না থাকলেও উত্তর কিন্তু ১ হবে। এটাই আমাদের বেস কেস। তাই একদম শুরুতে পুরো 
DP অ‍্যারের  টি ১ দিয়ে INITIALIZE করে নিতে  হবে।  

এরপর আমরা একটা ইনডেক্স i নিবো যা শুরুতে i = ১ দিয়ে  INITIALIZE করা।  এক্ষেত্রে আমরা ০ বেসড ইনডেক্সিং ব্যবহার করসি। 


![image](https://user-images.githubusercontent.com/63524824/126915907-5d7eef28-ad3d-411d-a07a-3a772b528fca.png)


এবং j ইনডেক্স ব্যবহার করবো যা সর্বদা ০ দ্বারা ইনিশিয়ালাইজ  করা থাকবে।  এর পর লুপ চলবে j থেকে i পর্যন্ত।  প্রতিবার লুপ শেষে i এর মান ১ করে ইনক্রিমেন্ট করে দিবো এবং আবার লুপ চালাবো।  এক্ষেত্রে মূল কাজ টা হলো array[i] এর চাইতে array[j] ছোট হলে , dp[j] এর সাথে ১ যোগ করে dp [i] এর মান আপডেট করবো যদি  dp[j]+1 ,  dp[i] থেকে বড় হয়।  

অর্থাৎ  ,
``` 

if ( array[i] > array[j] ) 

dp[i] = max ( dp[i] , dp[j]+1 ) ; 

```


#### Iterative Code : 

```
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fr(i,s,e) for(ll i=s;i<e;i++)
#define rfr(i,e,s) for(ll i=e;i>=s;i--)
#define nl  "\n"
#define mod 1000000007
using namespace std;


int main(){
    ll n , d , tmp  , pre = INT_MAX ;
    cin >> n ;
    ll ar[n] ;

    fr(i,0,n) cin >> ar[i] ;

    ll dp[n] ;
    fill (dp,dp+n,1);

    deque < int > lcs ;

    fr(i,1,n){
        fr(j,0,i){
            if ( ar[j] < ar[i]  ) dp[i] = max (dp[i],dp[j]+1);
        }
    }

    d = *max_element(dp,dp+n) ;
     cout <<"Length : " << d << endl;

return 0 ;
}

```
### রিকার্সিভ এপ্রোচ  : 


**প্রবলেমের প‍্যারামিটার বা স্টেট নির্ধারণ:**

আমরা প্রবলেমটা এভাবে চিন্তা করতে পারি: আমরা বর্তমানে ইনডেক্স 
i
 তে আছি এবং আমাদেরকে সবথেকে লম্বা সাবসিকোয়েন্স বের করতে হবে যেটা 
i
 তম ইনডেক্স থেকে শুরু হয়েছে। ধরা যাক 
f
(
i
)
 ফাংশনটা সেই জিনিসটা তোমাকে ক‍্যালকুলেট করে দিতে পারে। এখন আগের মতো 
f
(
0
)
 বের করলেই কি হবে? হবে না কারণ আমরা জানিনা LIS ঠিক কোন ইনডেক্স থেকে শুরু হয়েছে। আমাদেরকে ফাইনাল রেজাল্ট হবে হবে – 
m
a
x
(
f
(
0
)
,
f
(
1
)
…
.
f
(
n
–
1
)
)
।


**স্টেট ট্রানজিশন এবং রিকার্শন:**

এখন আমরা জানিনা ইনডেক্স 
i
 থেকে কোন ইনডেক্সে গেলে আমরা সব থেকে লম্বা সাবসিকোয়েন্স পাবো। এখন আমাদেরকে অনুমান করতে হবে। 
i
 থেকে যে যে ইনডেক্সে যাওয়া যায় সবগুলোয় গিয়ে গিয়ে আমরা দেখবো সেখান থেকে LIS এর দৈর্ঘ‍্য কত এবং যেটা সবথেকে লম্বা সেটাকে বেছে নিবো।

ইনডেক্স 
i
 থেকে কোন কোন ইনডেক্সে যাওয়া যায়? 
j
 ইনডেক্সকে দুটো শর্ত পূরণ করতে হবে:

যেহেতু অর্ডার মেইনটেইন করতে হবে, তাই নতুন ইনডেক্স 
j
 অবশ‍্যই 
i
 এর থেকে বড় হবে 
(
i
<
j
<
n
)
।
সেই সাথে A[j] এর মানও A[i] থেকে বড় হতে হবে 
(
A
[
j
]
>
A
[
i
]
)
।
অর্থাৎ (i < j < n) & (A[j] > A[i]) হলেই শুধুমাত্র আমরা 
i
 থেকে 
j
 তে যেতে পারবো। রিকার্শনটা তাহলে হবে এরকম

f
(
i
)=1
+
m
a
x
(
f
(
j
)
)
 
w
h
e
r
e
 
i
<
j
<
n
 
&
 
A[j] > A[i] 

