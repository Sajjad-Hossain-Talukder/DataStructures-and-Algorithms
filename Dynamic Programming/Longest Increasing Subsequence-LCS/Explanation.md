### লংগেস্ট ইনক্রিজিং সাবসিকোয়েন্স

ধরা যাক আমাদের নিচের ছবির মতো একটা অ‍্যারে আছে যার নাম A 

![image](https://user-images.githubusercontent.com/63524824/126882050-410c4793-e2db-4b21-9f11-4a9d3c1abf78.png)

একটা অ‍্যারের সাবসিকোয়েন্স বলতে বুঝায় অ‍্যারে থেকে কিছু এলিমেন্ট মুছে দিলে বাকি যে সিকোয়েন্সটা থাকে সেটা। এলিমেন্টগুলোর অর্ডারিং পরিবর্তন করা যাবে না। n  সাইজের একটা অ‍্যারের  2^n টি সাবসিকোয়েন্স থাকতে পারে (প্রতিটা এলিমেন্টের জন‍্য 
2টি চয়েস, রেখে দেয়া বা মুছে দেয়া)। ইনক্রিসিং সাবসিকোয়েন্স হলো এমন একটা সাবসিকোয়েন্স যার প্রতিটি পজিশনের ভ‍্যালু আগের পজিশনের ভ‍্যালুর থেকে বড়।


উপরের উদাহরণে [0,9]  , [5,9]  , [0,2,7]  , [0,2,3,4] কিছু ইনক্রিসিং সাবসিকোয়েন্স। সবথেকে লম্বা ইনক্রিসিং সাবসিকোয়েন্স বা LIS হলো [0,2,3,4]। 

প্রথমে আমরা চেষ্টা করবো LIS এর দৈর্ঘ‍্য বের করতে, এরপরে মূল সাবসিকোয়েন্সটাও ট্র‍্যাক করা শিখবো।


#### ইটারেটিভ এপ্রোচ  : 

আমাদের LIS বের করতে হবে n  সাইজের একটা অ‍্যারের মধ্যে থেকে।  এক্ষেত্রে  যদি কোনো Increasing Order এ সিকোয়েন্স না থাকলেও উত্তর কিন্তু ১ হবে। এটাই আমাদের বেস কেস। তাই একদম শুরুতে পুরো 
DP অ‍্যারের  টি ১ দিয়ে INITIALIZE করে নিতে  হবে।  

এরপর আমরা একটা ইনডেক্স i নিবো যা শুরুতে i = ১ দিয়ে  INITIALIZE করা।  এক্ষেত্রে আমরা ০ বেসড ইনডেক্সিং ব্যবহার করসি। 


![image](https://user-images.githubusercontent.com/63524824/126915907-5d7eef28-ad3d-411d-a07a-3a772b528fca.png)


এবং j ইনডেক্স ব্যবহার করবো যা সর্বদা ০ দ্বারা ইনিশিয়ালাইজ  করা থাকবে।  এর পর লুপ চলবে j থেকে i পর্যন্ত।  প্রতিবার লুপ শেষে i এর মান ১ করে ইনক্রিমেন্ট করে দিবো এবং আবার লুপ চালাবো।  এক্ষেত্রে মূল কাজ টা হলো array[i] এর চাইতে array[j] ছোট হলে , dp[j] এর সাথে ১ যোগ করে dp [i] এর মান আপডেট করবো যদি  dp[j]+1 ,  dp[i] থেকে বড় হয়।  

অর্থাৎ  ,
``` 

if ( array[i] > array[j] ) 

dp[i] = max ( dp[i] , dp[j]+1 ) ; 

```


#### Iterative Code : 

```
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fr(i,s,e) for(ll i=s;i<e;i++)
#define rfr(i,e,s) for(ll i=e;i>=s;i--)
#define nl  "\n"
#define mod 1000000007
using namespace std;


int main(){
    ll n , d , tmp  , pre = INT_MAX ;
    cin >> n ;
    ll ar[n] ;

    fr(i,0,n) cin >> ar[i] ;

    ll dp[n] ;
    fill (dp,dp+n,1);

    deque < int > lcs ;

    fr(i,1,n){
        fr(j,0,i){
            if ( ar[j] < ar[i]  ) dp[i] = max (dp[i],dp[j]+1);
        }
    }

    d = *max_element(dp,dp+n) ;
     cout <<"Length : " << d << endl;

return 0 ;
}

```


