### লংগেস্ট ইনক্রিজিং সাবসিকোয়েন্স

ধরা যাক আমাদের নিচের ছবির মতো একটা অ‍্যারে আছে যার নাম A 

![image](https://user-images.githubusercontent.com/63524824/126882050-410c4793-e2db-4b21-9f11-4a9d3c1abf78.png)

একটা অ‍্যারের সাবসিকোয়েন্স বলতে বুঝায় অ‍্যারে থেকে কিছু এলিমেন্ট মুছে দিলে বাকি যে সিকোয়েন্সটা থাকে সেটা। এলিমেন্টগুলোর অর্ডারিং পরিবর্তন করা যাবে না। n  সাইজের একটা অ‍্যারের  2^n টি সাবসিকোয়েন্স থাকতে পারে (প্রতিটা এলিমেন্টের জন‍্য 
2টি চয়েস, রেখে দেয়া বা মুছে দেয়া)। ইনক্রিসিং সাবসিকোয়েন্স হলো এমন একটা সাবসিকোয়েন্স যার প্রতিটি পজিশনের ভ‍্যালু আগের পজিশনের ভ‍্যালুর থেকে বড়।


উপরের উদাহরণে [0,9]  , [5,9]  , [0,2,7]  , [0,2,3,4] কিছু ইনক্রিসিং সাবসিকোয়েন্স। সবথেকে লম্বা ইনক্রিসিং সাবসিকোয়েন্স বা LIS হলো [0,2,3,4]। 

প্রথমে আমরা চেষ্টা করবো LIS এর দৈর্ঘ‍্য বের করতে, এরপরে মূল সাবসিকোয়েন্সটাও ট্র‍্যাক করা শিখবো।


#### ইটারেটিভ এপ্রোচ  : 

আমাদের LIS বের করতে হবে n  সাইজের একটা অ‍্যারের মধ্যে থেকে।  এক্ষেত্রে  যদি কোনো Increasing Order এ সিকোয়েন্স না থাকলেও উত্তর কিন্তু ১ হবে। এটাই আমাদের বেস কেস। তাই একদম শুরুতে পুরো 
DP অ‍্যারের  টি ১ দিয়ে INITIALIZE করে নিতে  হবে।  

এরপর আমরা একটা ইনডেক্স i নিবো যা শুরুতে i = ১ দিয়ে  INITIALIZE করা।  এক্ষেত্রে আমরা ০ বেসড ইনডেক্সিং ব্যবহার করসি। 


![image](https://user-images.githubusercontent.com/63524824/126915907-5d7eef28-ad3d-411d-a07a-3a772b528fca.png)


এবং j ইনডেক্স ব্যবহার করবো যা সর্বদা ০ দ্বারা ইনিশিয়ালাইজ  করা থাকবে।  এর পর লুপ চলবে j থেকে i পর্যন্ত।  প্রতিবার লুপ শেষে i এর মান ১ করে ইনক্রিমেন্ট করে দিবো এবং আবার লুপ চালাবো।  এক্ষেত্রে মূল কাজ টা হলো array[i] এর চাইতে array[j] ছোট হলে , dp[j] এর সাথে ১ যোগ করে dp [i] এর মান আপডেট করবো যদি  dp[j]+1 ,  dp[i] থেকে বড় হয়।  

অর্থাৎ  ,
``` 

if ( array[i] > array[j] ) 

dp[i] = max ( dp[i] , dp[j]+1 ) ; 

```


#### Iterative Code : 

```
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fr(i,s,e) for(ll i=s;i<e;i++)
#define rfr(i,e,s) for(ll i=e;i>=s;i--)
#define nl  "\n"
#define mod 1000000007
using namespace std;


int main(){
    ll n , d , tmp  , pre = INT_MAX ;
    cin >> n ;
    ll ar[n] ;

    fr(i,0,n) cin >> ar[i] ;

    ll dp[n] ;
    fill (dp,dp+n,1);

    deque < int > lcs ;

    fr(i,1,n){
        fr(j,0,i){
            if ( ar[j] < ar[i]  ) dp[i] = max (dp[i],dp[j]+1);
        }
    }

    d = *max_element(dp,dp+n) ;
     cout <<"Length : " << d << endl;

return 0 ;
}

```
### রিকার্সিভ এপ্রোচ  : 


**প্রবলেমের প‍্যারামিটার বা স্টেট নির্ধারণ:**

আমরা প্রবলেমটা এভাবে চিন্তা করতে পারি: আমরা বর্তমানে ইনডেক্স 
i
 তে আছি এবং আমাদেরকে সবথেকে লম্বা সাবসিকোয়েন্স বের করতে হবে যেটা 
i
 তম ইনডেক্স থেকে শুরু হয়েছে। ধরা যাক 
f
(
i
)
 ফাংশনটা সেই জিনিসটা তোমাকে ক‍্যালকুলেট করে দিতে পারে। এখন আগের মতো 
f
(
0
)
 বের করলেই কি হবে? হবে না কারণ আমরা জানিনা LIS ঠিক কোন ইনডেক্স থেকে শুরু হয়েছে। আমাদেরকে ফাইনাল রেজাল্ট হবে হবে – 
m
a
x
(
f
(
0
)
,
f
(
1
)
…
.
f
(
n
–
1
)
)
।


**স্টেট ট্রানজিশন এবং রিকার্শন:**

এখন আমরা জানিনা ইনডেক্স 
i
 থেকে কোন ইনডেক্সে গেলে আমরা সব থেকে লম্বা সাবসিকোয়েন্স পাবো। এখন আমাদেরকে অনুমান করতে হবে। 
i
 থেকে যে যে ইনডেক্সে যাওয়া যায় সবগুলোয় গিয়ে গিয়ে আমরা দেখবো সেখান থেকে LIS এর দৈর্ঘ‍্য কত এবং যেটা সবথেকে লম্বা সেটাকে বেছে নিবো।

ইনডেক্স 
i
 থেকে কোন কোন ইনডেক্সে যাওয়া যায়? 
j
 ইনডেক্সকে দুটো শর্ত পূরণ করতে হবে:

যেহেতু অর্ডার মেইনটেইন করতে হবে, তাই নতুন ইনডেক্স 
j
 অবশ‍্যই 
i
 এর থেকে বড় হবে 
(
i
<
j
<
n
)
।
সেই সাথে A[j] এর মানও A[i] থেকে বড় হতে হবে 
(
A
[
j
]
>
A
[
i
]
)
।
অর্থাৎ (i < j < n) & (A[j] > A[i]) হলেই শুধুমাত্র আমরা 
i
 থেকে 
j
 তে যেতে পারবো। রিকার্শনটা তাহলে হবে এরকম

f
(
i
)=1 + max ( f(j) ) , where ( i < j < n  & A[j] > A[i] ) 



কনফিউজড লাগছে? আগের শর্টেস্ট পাথ প্রবলেমের মত মনে করো প্রতিটা ইনডেক্স একটা করে শহর। এবার কোন শহর থেকে কোন শহরে যাওয়া যায় সেটা অ‍্যারো টেনে দেখিয়ে দাও উপরের শর্ত মেনে।


![image](https://user-images.githubusercontent.com/63524824/126917354-e9ede821-9a03-4c30-bb31-0db2a9dd5eeb.png)

অ‍্যারেটাকে আমরা গ্রাফ দিয়ে মডেলিং করলাম ভিজুয়ালাইজেশনের জন‍্য। আমাদের প্রবলেমটা এখন হয়ে গেলো ডিরেক্টেড অ‍্যাসাইক্লিক গ্রাফে লংগেস্ট পাথ বের করা!

ল‍ক্ষ‍্য করো আমাদের রিকার্শনে কোনো বেস কেস ডিফাইন করিনি। এই প্রবলেমে সেটা দরকার নেই কারণ এক স্টেট থেকে আরেক স্টেটে এমন ভাবে যাচ্ছি যে রিকার্শন এমনিই থেমে যাবে শেষে গিয়ে (আমরা সবসময় অ‍্যারের সামনে আগাচ্ছি, একসময় আর আগানো যাবে না)। রিকার্শন লুপে পড়ারও কোনো সম্ভাবনা নেই।

কোডটা লিখে ফেলি:


```
#define MAX_N 20
#define EMPTY_VALUE -1

int mem[MAX_N];

int f(int i, vector<int> &A) {
    if (mem[i] != EMPTY_VALUE) {
        return mem[i];
    }
    
    int ans = 0;
    for (int j = i + 1;j < A.size();j++) {
        if (A[j] > A[i]) {
            ans = max(ans, f(j, A));
        }
    }
    
    mem[i] = ans + 1;
    return mem[i];
}

int findLIS(vector<int> A){
  int ans = 0;
  
  for(int i = 0;i<A.size();i++) {
      mem[i] = EMPTY_VALUE;
  }
  
  for(int i = 0;i<A.size();i++) {
      ans = max(ans, f(i, A));
  }

  return ans;
}
```

**কমপ্লেক্সিটি** : শর্টেস্ট পাথ প্রবলেমের মতোই এটারও কমপ্লেক্সিটি 
O
(
n
∗
n
)
। ভিন্ন ভিন্ন স্টেট আছে 
n
 টা এবং প্রতিটি স্টেটের জন‍্য 
n
 সাইজের লুপ চালাতে হচ্ছে।
 
 #### N.B : Iterative one Edited By sajjad . Source : YT/Techdose
 
 
