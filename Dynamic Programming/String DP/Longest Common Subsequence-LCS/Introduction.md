### ডাইনামিক প্রোগ্রামিং - ৪ (লংগেস্ট কমন সাবসিকোয়েন্স)


এই প্রবলেমে তোমাকে দুটি স্ট্রিং দেয়া থাকবে S এবং W । তোমাকে তাদের মধ‍্যে লংগেস্ট কমন সাবসিকোয়েন্স এর দৈর্ঘ‍্য বের করতে হবে। সাবসিকোয়েন্সের সংজ্ঞাটা মনে করিয়ে দেই, **একটা স্ট্রিং থেকে কিছু ক‍্যারেক্টার মুছে দিলে যা বাকি থাকে সেটাই স্ট্রিংটা সাবসিকোয়েন্স। 
একটা স্ট্রিং এর 2^n টা সাবসিকোয়েন্স থাকতে পারে।** নিচের ছবিতে দুটি স্ট্রিং এবং তাদের লংগেস্ট কমন সাবসিকোয়েন্স দেখানো হয়েছে।

![image](https://user-images.githubusercontent.com/63524824/126533140-1c31653b-6d80-4c04-afbb-33d2eae01b3d.png)
                                               


LCS এর দৈর্ঘ‍‍্য এক্ষেত্রে 3 ।

আমাদের প্রবলেমটা হলো S এবং W এর LCS বের করতে হবে।

আমরা S এর ইনডেক্সগুলো হলো i এবং W এর ইনডেক্স j দিয়ে প্রকাশ করবো। এখন নিচ এখন আমরা এভাবে চিন্তা করতে পারি, শুরুতে আমরা দুটি স্ট্রিং এরই প্রথম ইনডেক্স i = 0  এবং j = 0 তে আছি এবং আমাদেরকে 
LCS(0,0) বের করতে হবে। এখন আমরা যদি যেকোনো (i,j)  এর জন‍্য LCS(i,j) বের করতে পারি তাহলেই কিন্তু আমাদের কাজ হয়ে যায়। 

**LCS(i,j)  বলতে বুঝাচ্ছে i এবং j তম ইনডেক্স থেকে শুরু হওয়া S এবং W এর সাফিক্সের LCS।** যেমন :

LCS(1,2) হলো “ELLOM” এবং “RLL” এর LCS।


এখন আমরা যখন (i,j) তে আছি তখন 3টি ঘটনা ঘটতে পারে:

- **S[i] == W[j]** , সেক্ষেত্রে ওই ক‍্যারেক্টারটাকে LCS এর অংশ ধরে নিয়ে আমরা বাকি সাফিক্সটুকুর LCS বের করতে পারি। তারমানে এখন আমাদের LCS(i+1,j+1) প্রবলেমটা সলভ করতে হবে, এখানে অনুমান করার কোনো ব‍্যাপার নেই।

![image](https://user-images.githubusercontent.com/63524824/126534186-42bfce41-4860-4734-99e8-915ba48616db.png)

- **S[i] != W[j]** , যেহেতু ক‍্যারেক্টার দুটি মিলছে না, অন্তত একটা ক‍্যারেক্টার আমাদের ফেলে দিতে হবে। এখন আমাদের হাতে দুটি চয়েজ, iতম ইনডেক্সটা ফেলে দিয়ে LCS(i+1,j) ক‍্যালকুলেট করা, অথবা  j তম ইনডেক্সটাকে ফেলে দিয়ে LCS(i,j+1)  ক‍্যালকুলেট করা। বুঝতেই পারছো আমরা দুটি পথে গিয়ে ম‍্যাক্সটাকে বেছে নিবো।

![image](https://user-images.githubusercontent.com/63524824/126534438-709085c0-5256-40b3-af64-bdc6d00eabdc.png)

- **i == n or j == m** হয়ে যাওয়া মানে কোন একটা স্ট্রিং এর শেষ মাথায় চলে গেছি, সেক্ষেত্রে 0 রিটার্ন করতে হবে।

আমরা আমাদের রিকার্সিভ ফর্মুলা তাহলে পেয়ে গিয়েছি:

![image](https://user-images.githubusercontent.com/63524824/126534603-3d25bb91-bca9-4194-9892-813d02cd94d6.png)

#### Code : 

```

#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fr(i,s,e) for(ll i=s;i<e;i++)
#define rfr(i,e,s) for(ll i=e;i>=s;i--)
#define nl  "\n"
#define mod 1000000007
using namespace std;

const ll sz = 1e3+5;
string s , p ;
ll cnt = 0 ;
ll dp[sz][sz];

ll lcs( ll i , ll j ){
    
    //cout << i <<" "<< j << endl;
    //cnt+=1;
    
    if ( i == s.size() || j == p.size() ) return 0 ;
    
    if ( dp[i][j] != -1 ) return dp[i][j] ;

    if ( s[i] == p[j] ) return dp[i][j] = 1+lcs(i+1,j+1) ;
    
    else return dp[i][j] = max(lcs(i+1,j),lcs(i,j+1));
    
}


int main(){
    
    cin >> s >> p ;
    memset(dp,-1,sizeof(dp));
    cout << lcs(0,0) << endl;
    //cout << cnt << endl;

return 0 ;
}



```
**কমপ্লেক্সিটি:**

আমাদের স্টেট হলো (i,j) যেখানে i এর মান হতে পারে [ 0 , n-1 ] এর মধ‍্যে এবংj এর মান হতে পারে [ 0 , m-1 ] এর মধ‍্যে । তাহলে মোট স্টেট আছে ( n * m ) টা এবং রিকার্সনের ভিতর আমরা বাকি যেসব কাজ করেছি সেগুলো কমপ্লেক্সিটি কনস্টেন্ট। তাহলে মোট কমপ্লেক্সিটি হবে O ( n * m ), জেনারেলাইজ করে বলা যায় O(n^2) .

### ইটারেটিভ ভার্সন: 


ইটারেটিভ ভার্সন লেখার জন‍্য আমাদেরকে বুঝতে হবে স্টেটগুলো কোন অর্ডারে আপডেট হচ্ছে । আমরা একটু DP টেবিলটার দিকে তাকাই:


![image](https://user-images.githubusercontent.com/63524824/126542861-c41e0ef8-e862-4622-8ccd-43e087765a89.png)

উপরিক্ত DP টেবিলের যেকোনো একটি ঘর DP [i][j] দিয়ে S[1,i] এর সাথে W[1,j]  পর্যন্ত স্ট্রিং এরে এর মধ্যে থাকা LCS এর দৈর্ঘ্য থাকে।  

টেবিলের কলাম  এবং রো বরাবর প্রথম এক ঘরে শূন্য দিয়ে বোঝানো হয়েছে কোনো আলফাবেট / লেটার  না নিলে সেক্ষেত্রে LCS দৈর্ঘ্য শূন্য হবে।  

পূর্বের রিকার্সিভ সমাধানের মতো এইখানেও দুইটি কেস আছে।  তারা হলো  : 

- S[i] == W[j] , যেহেতু লেটার দুইটি সমান অতএব LCS দৈর্ঘ্য ১ বৃদ্ধি পাবে।  সেক্ষেত্রে পূর্বের এই দুইটি লেটার নেয়ার পূর্বে যে দৈর্ঘ্য ছিলো ( যেটি এখন DP [i-1][j-1] ঘরে সংরক্ষিত ) তার সাথে ১ যোগ করবো।

-  S[i] != W[j] . সমান নয় বলে যেকোনো একটি নেওয়া যাবে।  আমাদের দুইটি আলাদা আলাদা নিয়ে দেখতে হবে কোনটি নিলে LCS দৈর্ঘ্য বেশি হয়।  যেইটার জন্য দৈর্ঘ্য বেশি হবে , DP[i][j] ঘরে সেই মানটি থাকবে। অতএব , DP[i][j] = max ( DP [i-1][j] , DP [i][j-1] )

#### Code :
```
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fr(i,s,e) for(ll i=s;i<e;i++)
#define rfr(i,e,s) for(ll i=e;i>=s;i--)
#define nl  "\n"
#define mod 1000000007
using namespace std;


int main(){
    string s ,p  ;
    cin >> s >> p ;

    ll dp[s.size()+1][p.size()+1] ;

    memset(dp,0,sizeof(dp)) ;

    fr(i,0,s.size()){
        fr(j,0,p.size()){
            if (s[i] == p[j]){
                dp[i+1][j+1] = dp[i][j]  + 1  ;
            }
            else {
                dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j]);
            }
        }
    }

    fr(i,0,s.size()+1){
        fr(j,0,p.size()+1){
            cout << dp[i][j] <<" ";
        }
        cout << endl;
    }

    cout <<"LCS : " << dp[s.size()][p.size()] << endl;


return 0 ;
}




```


