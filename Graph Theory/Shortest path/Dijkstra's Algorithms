Explanation taken : https://www.youtube.com/watch?v=NjJetq78wh4&t=53s      
ব্যাখ্যা : আমরা শর্টেস্ট পাথ খুঁজে পেতে চাই। যদি গ্রাফে কোনো Negative Edge এবং Negative Cycle না থাকে তাইলে 
Dijkstra's Algorithms ব্যবহার করবো। এইখানে আমরা min Priority Queue ব্যবহার করবো।  min Priority Queue তে কোনো 
ভ্যালু রাখলে সেটি Non - increasing Order এ সাজানো থাকে।  আমরা কোনো নোড থেকে এর adjacent node খুঁজবো তখন 
ওই নোড থেকে সবচাইতে কম কস্টের নোড এ যাবো min Priority Queue ব্যবহার করে।  কোড টা ভালো করে দেখলে বুঝা যাবে আশা করি। 

 min Priority Queue    =          priority_queue < pair <int,int> , vector< pair < int, int >> , greater< pair <int,int>>  > pq ;
                 
                 #include<bits/stdc++.h>
                  #define ll long long
                  #define pb push_back
                  using namespace std;

                  vector< pair<int,int> >graph[1000];
                  int visited[1000] ,dist[1000];


                  int main(){

                      priority_queue < pair <int,int> , vector< pair < int, int >> , greater< pair <int,int>>  > pq ;
                      pair <int,int>p;

                      int node,edge,x,y,w;
                      cin>>node>>edge;

                      for(int i = 1 ; i <= edge ; i+=1 ){
                          cin>>x>>y>>w;
                          graph[x] .pb({y,w});
                      }
                      int source , nd , cost ;
                      cin>>source ;

                      pq.push({0,source});


                      while( !pq.empty() ){
                          p = pq.top();
                          pq.pop();
                          cost = p.first;
                          nd = p.second;
                         // cout<<nd<<" cost : "<<cost<<endl;
                          dist[ nd ] = cost ;
                          visited[nd] = 1 ;

                          for(auto a : graph[ nd ]){
                                 // cout<<a.first<<" ";
                              if(!visited[ a.first ]){
                                  pq.push({a.second+cost , a.first});
                              }
                          }
                         // cout<<endl;
                      }

                      for(int i = 1 ; i<= node ; i+=1)
                          cout<<"node "<<i<<" dist : "<<dist[i]<<endl;


                     for(int i = 1 ; i<=node ; i++ ){
                      for(auto a : graph[i]){
                          cout<<a.first<<" ";
                      }
                      cout<<endl;
                     }

                  return 0;
                  }

                  /*
                  5 6
                  1 2 2
                  2 3 1
                  1 3 1
                  1 4 3
                  4 5 2
                  5 3 5


                  |*/
