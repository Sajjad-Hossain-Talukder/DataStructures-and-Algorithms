Explanation taken :   https://www.youtube.com/watch?v=7GoDDj3onfI  || https://www.youtube.com/watch?v=wQIb1NonMIM&t=922s

ব্যাখ্যা : আমরা শর্টেস্ট পাথ খুঁজে পেতে চাই। যদি গ্রাফে কোনো Negative Edge এবং Negative Cycle না থাকে তাইলে 
Dijkstra's Algorithms ব্যবহার করবো। এইখানে আমরা min Priority Queue ব্যবহার করবো।  min Priority Queue তে কোনো 
ভ্যালু রাখলে সেটি Non - increasing Order এ সাজানো থাকে।  আমরা কোনো নোড থেকে এর adjacent node খুঁজবো তখন 
ওই নোড থেকে সবচাইতে কম কস্টের নোড এ যাবো min Priority Queue ব্যবহার করে।  কোড টা ভালো করে দেখলে বুঝা যাবে আশা করি। 

 min Priority Queue    =          priority_queue < pair <int,int> , vector< pair < int, int >> , greater< pair <int,int>>  > pq ;
 
//Best Simulation Explanation :  https://www.educative.io/edpresso/how-to-implement-dijkstras-algorithm-in-cpp
https://pastebin.ubuntu.com/p/RX2ZhKyhtR/
Ref : http://www.shafaetsplanet.com/?p=1500
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                 
                   #include<bits/stdc++.h>
                   #define ll long long
                   #define pb push_back
                   using namespace std;

                   int main(){
                       int node , edge , x , y , c , nd = 1 , cost ;
                       cin >> node >> edge ;

                       vector< pair <int, int > > graph[ node + 5 ];
                       vector<int> ans ;

                       for ( int  i = 1 ; i <= edge ; i++ ){
                           cin >> x >> y >> c ;
                           graph[x] . pb ( { y , c });
                          // graph[y] . pb ( { x , c });
                       }

                       priority_queue < pair<int,int> , vector < pair<int,int> > , greater< pair<int,int> > > pq ;
                       pq.push({0,1});

                       vector< int > dist( node+5 , INT_MAX) ;
                       int  parent[node+5];
                       bool visited[node+5];
                       memset(visited, 0 , sizeof( visited));

                       dist[1] = 0 ;
                       parent[1] = -1 ;

                      while( ! pq.empty() ){

                           auto tm = pq.top() ;
                           pq.pop();
                           cost = tm.first ;
                           nd = tm.second ;

                           if( visited[nd] ) continue ;
                           else  visited[nd] = 1 ;

                           for( auto a : graph[nd] ){

                               if( dist[ a.first ] > cost+a.second && !visited[a.first] ){
                                   parent[a.first] = nd ;
                                   dist[ a.first ] = cost+a.second ;
                                   pq.push( {   dist[ a.first ] , a.first }) ;
                               }
                           }
                       }

                       for ( int i = 1 ; i<= node ; i++){
                          cout<<i<<" dist :  "<<dist[i]<<endl;
                         
                   return 0;
                   }


 /*
                  5 6
                  1 2 2
                  2 3 1
                  1 3 1
                  1 4 3
                  4 5 2
                  5 3 5
*/
