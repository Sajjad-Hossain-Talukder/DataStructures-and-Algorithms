বেলম্যান ফোর্ড এলগোরিদম ব্যবহার করে আমরা কোনো একটি গ্রাফের নেগেটিভ সাইকেল আছে নাকি সেটা খুঁজে বের করতে পারি। কোনো গ্রাফে নেগেটিভ এজ থাকলে সেক্ষেত্রে 
আমরা Dijkstra Algorithms ব্যবহার করে শর্টেস্ট পাথ বের করতে পারবো না। সেইক্ষেত্রে আমরা বেলম্যান ফোর্ড দিয়ে করতে পারবো। 

এক্ষেত্রে আমরা Dijkstra Algorithms ব্যবহার করবো ( নোড - ১ ) বার।  এইভাবে আমরা যে শর্টেস্ট পাথ পাবো সেটা নেগেটিভ এজ থাকলে সর্টেস্ট পাথ হবে। 
নেগেটিভ সাইকেল থাকলে শর্টেস্ট পাথ বের করা যাবে না। এক্ষেত্রে আমরা সেটা শুধু সনাক্ত করতে পারবো আরো একবার এক্সট্রা লুপ চালিয়ে। সর্বশেষ লুপ চালানোর পর 
যদি আগের শর্টেস্ট পাথ পাওয়া না যাই তাইলে বুজতে হবে এইখানে নেগেটিভ সাইকেল আছে।
নেগেটিভ সাইকেল ডিটেক্ট করার কোড বাইরে আছে।  এইখানে বেসিক বেলম্যান এবং পাথ প্রিন্ট করা হইসে। 

//------------------------------------------------------------------------------------------------------------------------------------------------//
                                          #include<bits/stdc++.h>
                                          #define ll long long
                                          #define pb push_back
                                          using namespace std;

                                          int i , f ;

                                          void path_print ( int parent[] , int n ){
                                              if( n == i ) return ;
                                              path_print(parent, parent[n]);
                                              cout<<parent[n]<<" ";

                                          }

                                          int main(){
                                              int node , edge , x , y , c ;
                                              cin >> node >> edge ;

                                              vector< pair <int,int> > adj[node+5] ;

                                              for ( int i = 1  ; i <= edge ; i++ ){
                                                  cin >> x >> y >> c ;
                                                  adj[x] .pb ( { y , c }) ;
                                              }

                                              ll dist[node+5] ;
                                              int parent[node+5];

                                              fill(dist,dist+node+5,INT_MAX);
                                              dist[1]  =  0 ;
                                              parent[1] = -1 ;

                                              for ( int i = 1 ; i < node ; i++ ){

                                                  for( int j = 1 ; j <= node ; j++ ){
                                                      for ( auto a : adj[j] ){
                                                              cout<<a.first<<" ";
                                                          if( dist[a.first] > dist[j]+a.second){
                                                              dist[a.first] = dist[j]+a.second;
                                                              parent[a.first] =  j ;
                                                          }
                                                      }
                                                  }
                                                /*  cout<<endl;
                                                  cout<<"relex : "<<i<<"      --- : \n";
                                                   for ( int j = 1 ; j <= node ; j++ ){
                                                  cout<<j<<" dist : "<<dist[j]<<endl;
                                                  }
                                                  */
                                              }
                                              // cout<<"---------------------------------------------\n";
                                              // Shortest distance print
                                              for ( int i = 1 ; i <= node ; i++ ){
                                                  cout<<i<<" dist : "<<dist[i]<<endl;
                                              }

                                              // Path print || input initial node to final node
                                              // Here source is Node 1 . We did code for getting shortest path from node 1 .
                                              // So here we use a destination node f . If there is a shortest path available from node 1 , then 
                                              // following function will print it .If there is no path , it will also print No path message .

                                              cin >> f ;

                                              if(  dist[f] == INT_MAX ) {
                                                  cout << "There is no Path\n";
                                              }
                                              else {
                                                      path_print ( parent , f) ;
                                                      cout<<f<<endl;
                                              }

                                          return 0;
                                          }


