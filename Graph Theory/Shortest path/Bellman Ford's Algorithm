বেলম্যান ফোর্ড এলগোরিদম ব্যবহার করে আমরা কোনো একটি গ্রাফের নেগেটিভ সাইকেল আছে নাকি সেটা খুঁজে বের করতে পারি। কোনো গ্রাফে নেগেটিভ এজ থাকলে সেক্ষেত্রে 
আমরা Dijkstra Algorithms ব্যবহার করে শর্টেস্ট পাথ বের করতে পারবো না। সেইক্ষেত্রে আমরা বেলম্যান ফোর্ড দিয়ে করতে পারবো। 

এক্ষেত্রে আমরা Dijkstra Algorithms ব্যবহার করবো ( নোড - ১ ) বার।  এইভাবে আমরা যে শর্টেস্ট পাথ পাবো সেটা নেগেটিভ এজ থাকলে সর্টেস্ট পাথ হবে। 
নেগেটিভ সাইকেল থাকলে শর্টেস্ট পাথ বের করা যাবে না। এক্ষেত্রে আমরা সেটা শুধু সনাক্ত করতে পারবো আরো একবার এক্সট্রা লুপ চালিয়ে। সর্বশেষ লুপ চালানোর পর 
যদি আগের শর্টেস্ট পাথ পাওয়া না যাই তাইলে বুজতে হবে এইখানে নেগেটিভ সাইকেল আছে।
নেগেটিভ সাইকেল ডিটেক্ট করার কোড বাইরে আছে।  এইখানে বেসিক বেলম্যান এবং পাথ প্রিন্ট করা হইসে। 

//------------------------------------------------------------------------------------------------------------------------------------------------//
                                              #include<bits/stdc++.h>
                                              #define ll long long
                                              #define pb push_back
                                              using namespace std;

                                              struct gp{
                                                  int p ;
                                                  int q ;
                                                  int c ;
                                              };


                                              int main(){
                                                  int node, edge , x , y , c;
                                                  cin >> node >> edge ;
                                                  
                                                  vector< gp > adj;

                                                  for( int i = 1 ; i <= edge ; i++ ){
                                                      cin >> x >> y >> c;
                                                      adj.pb({x,y,c});
                                                  }
                                                  
                                                  int source ;
                                                  cin >> source ;

                                                  ll dist[node+5] , temp_dist[node+5] ;
                                                  fill(dist , dist+node+5 , INT_MAX) ;

                                                  dist[source] = 0 ;

                                                  int parent[node+5];
                                                  parent[source] = -1 ;

                                                  for ( int i = 1 ; i < node ; i++ ){

                                                      for ( gp a : adj ){
                                                          if( dist[a.q] > dist[a.p]+a.c ){
                                                              dist[a.q] = dist[a.p]+a.c ;
                                                              parent[a.q] = a.p ; 
                                                          }
                                                      }

                                                  }

                                              return 0;
                                              }

